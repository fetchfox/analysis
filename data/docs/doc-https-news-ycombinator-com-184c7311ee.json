{
  "url": "https://news.ycombinator.com/item?id=41534179",
  "body": "<html lang=\"en\" op=\"item\"><head><meta name=\"referrer\" content=\"origin\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"stylesheet\" type=\"text/css\" href=\"news.css?rJWyZTUrrkHPi9ph1EY6\">\n        <link rel=\"icon\" href=\"y18.svg\">\n    <link rel=\"canonical\" href=\"https://news.ycombinator.com/item?id=41534179\"/>            <title>Modular Monoliths Are a Good Idea | Hacker News</title></head><body><center><table id=\"hnmain\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"85%\" bgcolor=\"#f6f6ef\">\n        <tr><td bgcolor=\"#ff6600\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"padding:2px\"><tr><td style=\"width:18px;padding-right:4px\"><a href=\"https://news.ycombinator.com\"><img src=\"y18.svg\" width=\"18\" height=\"18\" style=\"border:1px white solid; display:block\"></a></td>\n                  <td style=\"line-height:12pt; height:10px;\"><span class=\"pagetop\"><b class=\"hnname\"><a href=\"news\">Hacker News</a></b>\n                            <a href=\"newest\">new</a> | <a href=\"front\">past</a> | <a href=\"newcomments\">comments</a> | <a href=\"ask\">ask</a> | <a href=\"show\">show</a> | <a href=\"jobs\">jobs</a> | <a href=\"submit\" rel=\"nofollow\">submit</a>            </span></td><td style=\"text-align:right;padding-right:4px;\"><span class=\"pagetop\">\n                              <a href=\"login?goto=item%3Fid%3D41534179\">login</a>\n                          </span></td>\n              </tr></table></td></tr>\n<tr id=\"pagespace\" title=\"Modular Monoliths Are a Good Idea\" style=\"height:10px\"></tr><tr><td><table class=\"fatitem\" border=\"0\">\n        <tr class='athing' id='41534179'>\n      <td align=\"right\" valign=\"top\" class=\"title\"><span class=\"rank\"></span></td>      <td valign=\"top\" class=\"votelinks\"><center><a id='up_41534179' href='vote?id=41534179&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center></td><td class=\"title\"><span class=\"titleline\"><a href=\"https://materializedview.io/p/modular-monoliths-are-a-good-idea\">Modular Monoliths Are a Good Idea</a><span class=\"sitebit comhead\"> (<a href=\"from?site=materializedview.io\"><span class=\"sitestr\">materializedview.io</span></a>)</span></span></td></tr><tr><td colspan=\"2\"></td><td class=\"subtext\"><span class=\"subline\">\n          <span class=\"score\" id=\"score_41534179\">35 points</span> by <a href=\"user?id=riccomini\" class=\"hnuser\">riccomini</a> <span class=\"age\" title=\"2024-09-13T19:12:12.000000Z\"><a href=\"item?id=41534179\">1 hour ago</a></span> <span id=\"unv_41534179\"></span> | <a href=\"hide?id=41534179&amp;goto=item%3Fid%3D41534179\">hide</a> | <a href=\"https://hn.algolia.com/?query=Modular%20Monoliths%20Are%20a%20Good%20Idea&type=story&dateRange=all&sort=byDate&storyText=false&prefix&page=0\" class=\"hnpast\">past</a> | <a href=\"fave?id=41534179&amp;auth=798ee675e92211599bedae60e47583e703d859e8\">favorite</a> | <a href=\"item?id=41534179\">16&nbsp;comments</a>        </span>\n              </td></tr>\n            <tr><td style=\"height:10px\"></td></tr><tr><td colspan=\"2\"></td><td><form action=\"comment\" method=\"post\"><input type=\"hidden\" name=\"parent\" value=\"41534179\"><input type=\"hidden\" name=\"goto\" value=\"item?id=41534179\"><input type=\"hidden\" name=\"hmac\" value=\"2e0394d30efeabecd952393133baa43a01c7cf80\"><textarea name=\"text\" rows=\"8\" cols=\"80\" wrap=\"virtual\"></textarea><br><br>\n<input type=\"submit\" value=\"add comment\"></form></td></tr>  </table><br><br><table border=\"0\" class='comment-tree'>\n            <tr class='athing comtr' id='41534995'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534995' href='vote?id=41534995&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=gwbas1c\" class=\"hnuser\">gwbas1c</a> <span class=\"age\" title=\"2024-09-13T20:51:12.000000Z\"><a href=\"item?id=41534995\">16 minutes ago</a></span> <span id=\"unv_41534995\"></span>          <span class='navs'>\n             | <a href=\"#41534922\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534995\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">&gt; In practice microservices can be just as tough to wrangle as monoliths.<p>What&#x27;s worse: <i>Premature scalability</i>.<p>I joined one project that failed because the developers spent so much time on scalability, without realizing that <i>some basic optimization of their ORM</i> would be enough for a single instance to scale to handle any predictable load.<p>Now I&#x27;m wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it&#x27;s impossible to understand and maintain with a small team. A lot of &quot;cleanup&quot; often results in merging modules or cutting out abstraction.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534995&amp;goto=item%3Fid%3D41534179%2341534995\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534922'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534922' href='vote?id=41534922&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=andy_ppp\" class=\"hnuser\">andy_ppp</a> <span class=\"age\" title=\"2024-09-13T20:41:19.000000Z\"><a href=\"item?id=41534922\">26 minutes ago</a></span> <span id=\"unv_41534922\"></span>          <span class='navs'>\n             | <a href=\"#41534995\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534922\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC&#x2F;message passing to things like sockets&#x2F;channels&#x2F;presence and Live View.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534922&amp;goto=item%3Fid%3D41534179%2341534922\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534491'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534491' href='vote?id=41534491&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=mattnewton\" class=\"hnuser\">mattnewton</a> <span class=\"age\" title=\"2024-09-13T19:45:23.000000Z\"><a href=\"item?id=41534491\">1 hour ago</a></span> <span id=\"unv_41534491\"></span>          <span class='navs'>\n             | <a href=\"#41534922\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534491\" n=\"3\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it.<p>If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534491&amp;goto=item%3Fid%3D41534179%2341534491\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534984'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534984' href='vote?id=41534984&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T20:50:15.000000Z\"><a href=\"item?id=41534984\">17 minutes ago</a></span> <span id=\"unv_41534984\"></span>          <span class='navs'>\n             | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534984\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Do FAANG engineers normally advocate for more services instead of fewer? I haven&#x27;t gotten that impression.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534984&amp;goto=item%3Fid%3D41534179%2341534984\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41535070'><td><table border='0'>  <tr>    <td class='ind' indent='2'><img src=\"s.gif\" height=\"1\" width=\"80\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41535070' href='vote?id=41535070&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=aleksiy123\" class=\"hnuser\">aleksiy123</a> <span class=\"age\" title=\"2024-09-13T20:59:57.000000Z\"><a href=\"item?id=41535070\">7 minutes ago</a></span> <span id=\"unv_41535070\"></span>          <span class='navs'>\n             | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">root</a> | <a href=\"#41534984\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41535070\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Smaller services but not necessarily more binaries.<p>The current direction I think is to build composable services that could be run together or separately.<p>Here is some public work in this direction from Google<p><a href=\"https:&#x2F;&#x2F;serviceweaver.dev&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;serviceweaver.dev&#x2F;</a></div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41535070&amp;goto=item%3Fid%3D41534179%2341535070\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                        <tr class='athing comtr' id='41534906'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534906' href='vote?id=41534906&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=alganet\" class=\"hnuser\">alganet</a> <span class=\"age\" title=\"2024-09-13T20:39:25.000000Z\"><a href=\"item?id=41534906\">27 minutes ago</a></span> <span id=\"unv_41534906\"></span>          <span class='navs'>\n             | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534906\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">A good analogy is lacking though. &quot;Modular Monolith&quot; sounds like a contradiction. It doesn&#x27;t help the idea.<p>It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it&#x27;s being roughly patched together into meaningless buzzwords.<p>It&#x27;s no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind.<p>What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let&#x27;s not go into biology though, that can&#x27;t do any good.<p>Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It&#x27;s all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534906&amp;goto=item%3Fid%3D41534179%2341534906\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41535073'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41535073' href='vote?id=41535073&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=bbor\" class=\"hnuser\">bbor</a> <span class=\"age\" title=\"2024-09-13T21:00:10.000000Z\"><a href=\"item?id=41535073\">7 minutes ago</a></span> <span id=\"unv_41535073\"></span>          <span class='navs'>\n             | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41535073\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly…<p>Personally, I’m putting all my money on <i>cognitive</i>, and the terms that go along with it - say, <i>social</i>, <i>agential</i>, <i>discursive</i>, and <i>conversational</i>. Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as <i>dialectic</i> (a highly-mutable data structure with holistic modification functions?), <i>architectonic</i> (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and <i>striated vs smooth</i> systems (describes the level of obstruction&#x2F;complication present in each?).<p>Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,<p><pre><code>  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. \n</code></pre>\n- Alan Turing, 1950’s <i>Computing Machinery and Intelligence</i></div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41535073&amp;goto=item%3Fid%3D41534179%2341535073\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                  <tr class='athing comtr' id='41535107'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41535107' href='vote?id=41535107&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=stephen\" class=\"hnuser\">stephen</a> <span class=\"age\" title=\"2024-09-13T21:04:01.000000Z\"><a href=\"item?id=41535107\">3 minutes ago</a></span> <span id=\"unv_41535107\"></span>          <span class='navs'>\n             | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41535107\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-)<p>I.e. quoting from the post:<p>- monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- <i>I am not aware of any tools that help detect such boundaries</i><p>Exactly.<p>For as much press as &quot;modular monoliths&quot; have gotten, breaking up a large codebase is cool&#x2F;fine&#x2F;whatever--breaking up a large <i>domain model</i> is imo the &quot;killer app&quot; of modular monoliths, and what we&#x27;re missing (basically the Rails of modular monoliths).</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41535107&amp;goto=item%3Fid%3D41534179%2341535107\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534678'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534678' href='vote?id=41534678&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=ljm\" class=\"hnuser\">ljm</a> <span class=\"age\" title=\"2024-09-13T20:12:33.000000Z\"><a href=\"item?id=41534678\">54 minutes ago</a></span> <span id=\"unv_41534678\"></span>          <span class='navs'>\n             | <a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534678\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I can&#x27;t help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There&#x27;s nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It&#x27;s all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice.<p>The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it&#x27;s worth. For a small, pizza-sized team it&#x27;s probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove.<p>If you&#x27;re going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it&#x27;s not really a monolith any more, it&#x27;s just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos.<p>Fundamentally I think that you&#x27;re just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534678&amp;goto=item%3Fid%3D41534179%2341534678\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534954'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534954' href='vote?id=41534954&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T20:46:07.000000Z\"><a href=\"item?id=41534954\">21 minutes ago</a></span> <span id=\"unv_41534954\"></span>          <span class='navs'>\n             | <a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534954\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I think the assumption here is that &quot;microservices&quot; means each team is dealing with lots of services. Sometimes it&#x27;s like that. But if you go by the &quot;one service &lt;=&gt; one database&quot; rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams&#x27; stuff, you&#x27;ll be thankful it&#x27;s across an RPC. Especially if you don&#x27;t agree with that other team on what language to write in.<p>It&#x27;d really help to see a concrete example of a modular monolith compared to the microservice equivalent.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534954&amp;goto=item%3Fid%3D41534179%2341534954\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                  <tr class='athing comtr' id='41534813'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534813' href='vote?id=41534813&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=mushufasa\" class=\"hnuser\">mushufasa</a> <span class=\"age\" title=\"2024-09-13T20:29:05.000000Z\"><a href=\"item?id=41534813\">38 minutes ago</a></span> <span id=\"unv_41534813\"></span>          <span class='navs'>\n             | <a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534813\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Would Django&#x27;s concept of an &#x27;app&#x27; fit your definition of modular monoliths?<p><a href=\"https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;applications&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;applications&#x2F;</a><p>In a nutshell, each django project is an &#x27;app&#x27; and you can &#x27;install&#x27; multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an &#x27;app&#x27;.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534813&amp;goto=item%3Fid%3D41534179%2341534813\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534507'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534507' href='vote?id=41534507&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T19:47:28.000000Z\"><a href=\"item?id=41534507\">1 hour ago</a></span> <span id=\"unv_41534507\"></span>          <span class='navs'>\n             | <a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534507\" n=\"3\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">&quot;To get similar characteristics from a monolith, developers need:<p><pre><code>    Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement&quot;\n</code></pre>\nThis sounds a lot like microservices, most of all the last point. Is the only difference that you don&#x27;t use RPCs?</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534507&amp;goto=item%3Fid%3D41534179%2341534507\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534703'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534703' href='vote?id=41534703&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=nine_k\" class=\"hnuser\">nine_k</a> <span class=\"age\" title=\"2024-09-13T20:15:44.000000Z\"><a href=\"item?id=41534703\">51 minutes ago</a></span> <span id=\"unv_41534703\"></span>          <span class='navs'>\n             | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534703\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">&gt; <i>the only difference that you don&#x27;t use RPCs</i><p>But it&#x27;s a <i>huge</i> difference. No RPC overhead. No lost &#x2F; duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog).<p>Local deployment is dead simple, and you can&#x27;t forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services.<p>Beside that, the build step is much simpler. Common libraries&#x27; versions can never diverge, because there&#x27;s one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules.<p>With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It&#x27;s trivially easy to factor out common parts into another self-contained module.<p>Still you have all the advantages of fast incremental &#x2F; partial builds, contained dependencies, and some of the advantages of isolated &#x2F; parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534703&amp;goto=item%3Fid%3D41534179%2341534703\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534898'><td><table border='0'>  <tr>    <td class='ind' indent='2'><img src=\"s.gif\" height=\"1\" width=\"80\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534898' href='vote?id=41534898&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T20:38:34.000000Z\"><a href=\"item?id=41534898\">28 minutes ago</a></span> <span id=\"unv_41534898\"></span>          <span class='navs'>\n             | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">root</a> | <a href=\"#41534703\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534898\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">There would be a mix of versions, managed via branches.<p>The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won&#x27;t be any easier as a monorepo. First thing you&#x27;ll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don&#x27;t want to bother running locally.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534898&amp;goto=item%3Fid%3D41534179%2341534898\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                        <tr class='athing comtr' id='41534529'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534529' href='vote?id=41534529&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=throwaway984393\" class=\"hnuser\">throwaway984393</a> <span class=\"age\" title=\"2024-09-13T19:50:51.000000Z\"><a href=\"item?id=41534529\">1 hour ago</a></span> <span id=\"unv_41534529\"></span>          <span class='navs'>\n             | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">prev</a> <a class=\"togg clicky\" id=\"41534529\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I&#x27;m nearing greybeard status, so I have to chime in on the &quot;get off my lawn&quot; aspect.<p>There is no one general &quot;good engineering&quot;. Everything is different. Labels suck because even if you called one thing &quot;microservices&quot;, or even &quot;monolith of microservices&quot;, I can show you 10 different ways that can end up. So &quot;modular monolith&quot; is just as useless a descriptor; it&#x27;s too vague.<p>Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality.<p>I personally haven&#x27;t seen that method used at corporations. If there are libraries, they&#x27;re almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency.<p>If you aren&#x27;t aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can &quot;just&quot; install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you&#x27;ve never done packaging for a distro or a language (and I mean 250+ hours of it), you won&#x27;t understand how much work it is or how it will affect your own projects.<p>So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don&#x27;t just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534529&amp;goto=item%3Fid%3D41534179%2341534529\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534717'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534717' href='vote?id=41534717&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=transpute\" class=\"hnuser\">transpute</a> <span class=\"age\" title=\"2024-09-13T20:17:19.000000Z\"><a href=\"item?id=41534717\">50 minutes ago</a></span> <span id=\"unv_41534717\"></span>          <span class='navs'>\n             | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">parent</a> <a class=\"togg clicky\" id=\"41534717\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\"><i>&gt; If you aren&#x27;t aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can &quot;just&quot; install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you&#x27;ve never done packaging for a distro or a language (and I mean 250+ hours of it), you won&#x27;t understand how much work it is or how it will affect your own projects.</i><p>When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop&#x2F;test a fix and shepherd it through review&#x2F;approval by senior engineers.<p>There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb&#x2F;.rpm, then image customization, A&#x2F;B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software &quot;bill of materials&quot; aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534717&amp;goto=item%3Fid%3D41534179%2341534717\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                  </table>\n  <br><br>\n</td></tr>\n<tr><td><img src=\"s.gif\" height=\"10\" width=\"0\"><table width=\"100%\" cellspacing=\"0\" cellpadding=\"1\"><tr><td bgcolor=\"#ff6600\"></td></tr></table><br>\n<center><span class=\"yclinks\"><a href=\"newsguidelines.html\">Guidelines</a> | <a href=\"newsfaq.html\">FAQ</a> | <a href=\"lists\">Lists</a> | <a href=\"https://github.com/HackerNews/API\">API</a> | <a href=\"security.html\">Security</a> | <a href=\"https://www.ycombinator.com/legal/\">Legal</a> | <a href=\"https://www.ycombinator.com/apply/\">Apply to YC</a> | <a href=\"mailto:hn@ycombinator.com\">Contact</a></span><br><br>\n<form method=\"get\" action=\"//hn.algolia.com/\">Search: <input type=\"text\" name=\"q\" size=\"17\" autocorrect=\"off\" spellcheck=\"false\" autocapitalize=\"off\" autocomplete=\"off\"></form></center></td></tr>      </table></center></body>\n      <script type='text/javascript' src='hn.js?rJWyZTUrrkHPi9ph1EY6'></script>\n  </html>\n",
  "html": "<html lang=\"en\" op=\"item\"><head><meta name=\"referrer\" content=\"origin\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"stylesheet\" type=\"text/css\" href=\"news.css?rJWyZTUrrkHPi9ph1EY6\">\n        <link rel=\"icon\" href=\"y18.svg\">\n    <link rel=\"canonical\" href=\"https://news.ycombinator.com/item?id=41534179\"/>            <title>Modular Monoliths Are a Good Idea | Hacker News</title></head><body><center><table id=\"hnmain\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"85%\" bgcolor=\"#f6f6ef\">\n        <tr><td bgcolor=\"#ff6600\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"padding:2px\"><tr><td style=\"width:18px;padding-right:4px\"><a href=\"https://news.ycombinator.com\"><img src=\"y18.svg\" width=\"18\" height=\"18\" style=\"border:1px white solid; display:block\"></a></td>\n                  <td style=\"line-height:12pt; height:10px;\"><span class=\"pagetop\"><b class=\"hnname\"><a href=\"news\">Hacker News</a></b>\n                            <a href=\"newest\">new</a> | <a href=\"front\">past</a> | <a href=\"newcomments\">comments</a> | <a href=\"ask\">ask</a> | <a href=\"show\">show</a> | <a href=\"jobs\">jobs</a> | <a href=\"submit\" rel=\"nofollow\">submit</a>            </span></td><td style=\"text-align:right;padding-right:4px;\"><span class=\"pagetop\">\n                              <a href=\"login?goto=item%3Fid%3D41534179\">login</a>\n                          </span></td>\n              </tr></table></td></tr>\n<tr id=\"pagespace\" title=\"Modular Monoliths Are a Good Idea\" style=\"height:10px\"></tr><tr><td><table class=\"fatitem\" border=\"0\">\n        <tr class='athing' id='41534179'>\n      <td align=\"right\" valign=\"top\" class=\"title\"><span class=\"rank\"></span></td>      <td valign=\"top\" class=\"votelinks\"><center><a id='up_41534179' href='vote?id=41534179&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center></td><td class=\"title\"><span class=\"titleline\"><a href=\"https://materializedview.io/p/modular-monoliths-are-a-good-idea\">Modular Monoliths Are a Good Idea</a><span class=\"sitebit comhead\"> (<a href=\"from?site=materializedview.io\"><span class=\"sitestr\">materializedview.io</span></a>)</span></span></td></tr><tr><td colspan=\"2\"></td><td class=\"subtext\"><span class=\"subline\">\n          <span class=\"score\" id=\"score_41534179\">35 points</span> by <a href=\"user?id=riccomini\" class=\"hnuser\">riccomini</a> <span class=\"age\" title=\"2024-09-13T19:12:12.000000Z\"><a href=\"item?id=41534179\">1 hour ago</a></span> <span id=\"unv_41534179\"></span> | <a href=\"hide?id=41534179&amp;goto=item%3Fid%3D41534179\">hide</a> | <a href=\"https://hn.algolia.com/?query=Modular%20Monoliths%20Are%20a%20Good%20Idea&type=story&dateRange=all&sort=byDate&storyText=false&prefix&page=0\" class=\"hnpast\">past</a> | <a href=\"fave?id=41534179&amp;auth=798ee675e92211599bedae60e47583e703d859e8\">favorite</a> | <a href=\"item?id=41534179\">16&nbsp;comments</a>        </span>\n              </td></tr>\n            <tr><td style=\"height:10px\"></td></tr><tr><td colspan=\"2\"></td><td><form action=\"comment\" method=\"post\"><input type=\"hidden\" name=\"parent\" value=\"41534179\"><input type=\"hidden\" name=\"goto\" value=\"item?id=41534179\"><input type=\"hidden\" name=\"hmac\" value=\"2e0394d30efeabecd952393133baa43a01c7cf80\"><textarea name=\"text\" rows=\"8\" cols=\"80\" wrap=\"virtual\"></textarea><br><br>\n<input type=\"submit\" value=\"add comment\"></form></td></tr>  </table><br><br><table border=\"0\" class='comment-tree'>\n            <tr class='athing comtr' id='41534995'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534995' href='vote?id=41534995&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=gwbas1c\" class=\"hnuser\">gwbas1c</a> <span class=\"age\" title=\"2024-09-13T20:51:12.000000Z\"><a href=\"item?id=41534995\">16 minutes ago</a></span> <span id=\"unv_41534995\"></span>          <span class='navs'>\n             | <a href=\"#41534922\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534995\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">&gt; In practice microservices can be just as tough to wrangle as monoliths.<p>What&#x27;s worse: <i>Premature scalability</i>.<p>I joined one project that failed because the developers spent so much time on scalability, without realizing that <i>some basic optimization of their ORM</i> would be enough for a single instance to scale to handle any predictable load.<p>Now I&#x27;m wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it&#x27;s impossible to understand and maintain with a small team. A lot of &quot;cleanup&quot; often results in merging modules or cutting out abstraction.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534995&amp;goto=item%3Fid%3D41534179%2341534995\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534922'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534922' href='vote?id=41534922&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=andy_ppp\" class=\"hnuser\">andy_ppp</a> <span class=\"age\" title=\"2024-09-13T20:41:19.000000Z\"><a href=\"item?id=41534922\">26 minutes ago</a></span> <span id=\"unv_41534922\"></span>          <span class='navs'>\n             | <a href=\"#41534995\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534922\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC&#x2F;message passing to things like sockets&#x2F;channels&#x2F;presence and Live View.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534922&amp;goto=item%3Fid%3D41534179%2341534922\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534491'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534491' href='vote?id=41534491&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=mattnewton\" class=\"hnuser\">mattnewton</a> <span class=\"age\" title=\"2024-09-13T19:45:23.000000Z\"><a href=\"item?id=41534491\">1 hour ago</a></span> <span id=\"unv_41534491\"></span>          <span class='navs'>\n             | <a href=\"#41534922\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534491\" n=\"3\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it.<p>If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534491&amp;goto=item%3Fid%3D41534179%2341534491\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534984'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534984' href='vote?id=41534984&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T20:50:15.000000Z\"><a href=\"item?id=41534984\">17 minutes ago</a></span> <span id=\"unv_41534984\"></span>          <span class='navs'>\n             | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534984\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Do FAANG engineers normally advocate for more services instead of fewer? I haven&#x27;t gotten that impression.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534984&amp;goto=item%3Fid%3D41534179%2341534984\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41535070'><td><table border='0'>  <tr>    <td class='ind' indent='2'><img src=\"s.gif\" height=\"1\" width=\"80\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41535070' href='vote?id=41535070&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=aleksiy123\" class=\"hnuser\">aleksiy123</a> <span class=\"age\" title=\"2024-09-13T20:59:57.000000Z\"><a href=\"item?id=41535070\">7 minutes ago</a></span> <span id=\"unv_41535070\"></span>          <span class='navs'>\n             | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">root</a> | <a href=\"#41534984\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41535070\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Smaller services but not necessarily more binaries.<p>The current direction I think is to build composable services that could be run together or separately.<p>Here is some public work in this direction from Google<p><a href=\"https:&#x2F;&#x2F;serviceweaver.dev&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;serviceweaver.dev&#x2F;</a></div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41535070&amp;goto=item%3Fid%3D41534179%2341535070\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                        <tr class='athing comtr' id='41534906'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534906' href='vote?id=41534906&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=alganet\" class=\"hnuser\">alganet</a> <span class=\"age\" title=\"2024-09-13T20:39:25.000000Z\"><a href=\"item?id=41534906\">27 minutes ago</a></span> <span id=\"unv_41534906\"></span>          <span class='navs'>\n             | <a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534906\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">A good analogy is lacking though. &quot;Modular Monolith&quot; sounds like a contradiction. It doesn&#x27;t help the idea.<p>It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it&#x27;s being roughly patched together into meaningless buzzwords.<p>It&#x27;s no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind.<p>What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let&#x27;s not go into biology though, that can&#x27;t do any good.<p>Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It&#x27;s all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534906&amp;goto=item%3Fid%3D41534179%2341534906\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41535073'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41535073' href='vote?id=41535073&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=bbor\" class=\"hnuser\">bbor</a> <span class=\"age\" title=\"2024-09-13T21:00:10.000000Z\"><a href=\"item?id=41535073\">7 minutes ago</a></span> <span id=\"unv_41535073\"></span>          <span class='navs'>\n             | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41535073\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly…<p>Personally, I’m putting all my money on <i>cognitive</i>, and the terms that go along with it - say, <i>social</i>, <i>agential</i>, <i>discursive</i>, and <i>conversational</i>. Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as <i>dialectic</i> (a highly-mutable data structure with holistic modification functions?), <i>architectonic</i> (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and <i>striated vs smooth</i> systems (describes the level of obstruction&#x2F;complication present in each?).<p>Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,<p><pre><code>  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. \n</code></pre>\n- Alan Turing, 1950’s <i>Computing Machinery and Intelligence</i></div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41535073&amp;goto=item%3Fid%3D41534179%2341535073\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                  <tr class='athing comtr' id='41535107'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41535107' href='vote?id=41535107&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=stephen\" class=\"hnuser\">stephen</a> <span class=\"age\" title=\"2024-09-13T21:04:01.000000Z\"><a href=\"item?id=41535107\">3 minutes ago</a></span> <span id=\"unv_41535107\"></span>          <span class='navs'>\n             | <a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41535107\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-)<p>I.e. quoting from the post:<p>- monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- <i>I am not aware of any tools that help detect such boundaries</i><p>Exactly.<p>For as much press as &quot;modular monoliths&quot; have gotten, breaking up a large codebase is cool&#x2F;fine&#x2F;whatever--breaking up a large <i>domain model</i> is imo the &quot;killer app&quot; of modular monoliths, and what we&#x27;re missing (basically the Rails of modular monoliths).</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41535107&amp;goto=item%3Fid%3D41534179%2341535107\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534678'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534678' href='vote?id=41534678&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=ljm\" class=\"hnuser\">ljm</a> <span class=\"age\" title=\"2024-09-13T20:12:33.000000Z\"><a href=\"item?id=41534678\">54 minutes ago</a></span> <span id=\"unv_41534678\"></span>          <span class='navs'>\n             | <a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534678\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I can&#x27;t help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There&#x27;s nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It&#x27;s all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice.<p>The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it&#x27;s worth. For a small, pizza-sized team it&#x27;s probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove.<p>If you&#x27;re going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it&#x27;s not really a monolith any more, it&#x27;s just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos.<p>Fundamentally I think that you&#x27;re just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534678&amp;goto=item%3Fid%3D41534179%2341534678\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534954'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534954' href='vote?id=41534954&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T20:46:07.000000Z\"><a href=\"item?id=41534954\">21 minutes ago</a></span> <span id=\"unv_41534954\"></span>          <span class='navs'>\n             | <a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534954\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I think the assumption here is that &quot;microservices&quot; means each team is dealing with lots of services. Sometimes it&#x27;s like that. But if you go by the &quot;one service &lt;=&gt; one database&quot; rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams&#x27; stuff, you&#x27;ll be thankful it&#x27;s across an RPC. Especially if you don&#x27;t agree with that other team on what language to write in.<p>It&#x27;d really help to see a concrete example of a modular monolith compared to the microservice equivalent.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534954&amp;goto=item%3Fid%3D41534179%2341534954\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                  <tr class='athing comtr' id='41534813'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534813' href='vote?id=41534813&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=mushufasa\" class=\"hnuser\">mushufasa</a> <span class=\"age\" title=\"2024-09-13T20:29:05.000000Z\"><a href=\"item?id=41534813\">38 minutes ago</a></span> <span id=\"unv_41534813\"></span>          <span class='navs'>\n             | <a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534813\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">Would Django&#x27;s concept of an &#x27;app&#x27; fit your definition of modular monoliths?<p><a href=\"https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;applications&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;5.1&#x2F;ref&#x2F;applications&#x2F;</a><p>In a nutshell, each django project is an &#x27;app&#x27; and you can &#x27;install&#x27; multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an &#x27;app&#x27;.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534813&amp;goto=item%3Fid%3D41534179%2341534813\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n            <tr class='athing comtr' id='41534507'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534507' href='vote?id=41534507&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T19:47:28.000000Z\"><a href=\"item?id=41534507\">1 hour ago</a></span> <span id=\"unv_41534507\"></span>          <span class='navs'>\n             | <a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">prev</a> | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534507\" n=\"3\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">&quot;To get similar characteristics from a monolith, developers need:<p><pre><code>    Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement&quot;\n</code></pre>\nThis sounds a lot like microservices, most of all the last point. Is the only difference that you don&#x27;t use RPCs?</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534507&amp;goto=item%3Fid%3D41534179%2341534507\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534703'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534703' href='vote?id=41534703&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=nine_k\" class=\"hnuser\">nine_k</a> <span class=\"age\" title=\"2024-09-13T20:15:44.000000Z\"><a href=\"item?id=41534703\">51 minutes ago</a></span> <span id=\"unv_41534703\"></span>          <span class='navs'>\n             | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534703\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">&gt; <i>the only difference that you don&#x27;t use RPCs</i><p>But it&#x27;s a <i>huge</i> difference. No RPC overhead. No lost &#x2F; duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog).<p>Local deployment is dead simple, and you can&#x27;t forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services.<p>Beside that, the build step is much simpler. Common libraries&#x27; versions can never diverge, because there&#x27;s one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules.<p>With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It&#x27;s trivially easy to factor out common parts into another self-contained module.<p>Still you have all the advantages of fast incremental &#x2F; partial builds, contained dependencies, and some of the advantages of isolated &#x2F; parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534703&amp;goto=item%3Fid%3D41534179%2341534703\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534898'><td><table border='0'>  <tr>    <td class='ind' indent='2'><img src=\"s.gif\" height=\"1\" width=\"80\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534898' href='vote?id=41534898&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a> <span class=\"age\" title=\"2024-09-13T20:38:34.000000Z\"><a href=\"item?id=41534898\">28 minutes ago</a></span> <span id=\"unv_41534898\"></span>          <span class='navs'>\n             | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">root</a> | <a href=\"#41534703\" class=\"clicky\" aria-hidden=\"true\">parent</a> | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a> <a class=\"togg clicky\" id=\"41534898\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">There would be a mix of versions, managed via branches.<p>The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won&#x27;t be any easier as a monorepo. First thing you&#x27;ll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don&#x27;t want to bother running locally.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534898&amp;goto=item%3Fid%3D41534179%2341534898\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                        <tr class='athing comtr' id='41534529'><td><table border='0'>  <tr>    <td class='ind' indent='0'><img src=\"s.gif\" height=\"1\" width=\"0\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534529' href='vote?id=41534529&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=throwaway984393\" class=\"hnuser\">throwaway984393</a> <span class=\"age\" title=\"2024-09-13T19:50:51.000000Z\"><a href=\"item?id=41534529\">1 hour ago</a></span> <span id=\"unv_41534529\"></span>          <span class='navs'>\n             | <a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">prev</a> <a class=\"togg clicky\" id=\"41534529\" n=\"2\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\">I&#x27;m nearing greybeard status, so I have to chime in on the &quot;get off my lawn&quot; aspect.<p>There is no one general &quot;good engineering&quot;. Everything is different. Labels suck because even if you called one thing &quot;microservices&quot;, or even &quot;monolith of microservices&quot;, I can show you 10 different ways that can end up. So &quot;modular monolith&quot; is just as useless a descriptor; it&#x27;s too vague.<p>Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality.<p>I personally haven&#x27;t seen that method used at corporations. If there are libraries, they&#x27;re almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency.<p>If you aren&#x27;t aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can &quot;just&quot; install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you&#x27;ve never done packaging for a distro or a language (and I mean 250+ hours of it), you won&#x27;t understand how much work it is or how it will affect your own projects.<p>So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don&#x27;t just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534529&amp;goto=item%3Fid%3D41534179%2341534529\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                <tr class='athing comtr' id='41534717'><td><table border='0'>  <tr>    <td class='ind' indent='1'><img src=\"s.gif\" height=\"1\" width=\"40\"></td><td valign=\"top\" class=\"votelinks\">\n      <center><a id='up_41534717' href='vote?id=41534717&amp;how=up&amp;goto=item%3Fid%3D41534179'><div class='votearrow' title='upvote'></div></a></center>    </td><td class=\"default\"><div style=\"margin-top:2px; margin-bottom:-10px;\"><span class=\"comhead\">\n          <a href=\"user?id=transpute\" class=\"hnuser\">transpute</a> <span class=\"age\" title=\"2024-09-13T20:17:19.000000Z\"><a href=\"item?id=41534717\">50 minutes ago</a></span> <span id=\"unv_41534717\"></span>          <span class='navs'>\n             | <a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">parent</a> <a class=\"togg clicky\" id=\"41534717\" n=\"1\" href=\"javascript:void(0)\">[–]</a><span class=\"onstory\"></span>          </span>\n                  </span></div><br><div class=\"comment\">\n                  <div class=\"commtext c00\"><i>&gt; If you aren&#x27;t aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can &quot;just&quot; install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you&#x27;ve never done packaging for a distro or a language (and I mean 250+ hours of it), you won&#x27;t understand how much work it is or how it will affect your own projects.</i><p>When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop&#x2F;test a fix and shepherd it through review&#x2F;approval by senior engineers.<p>There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb&#x2F;.rpm, then image customization, A&#x2F;B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software &quot;bill of materials&quot; aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.</div>\n              <div class='reply'>        <p><font size=\"1\">\n                      <u><a href=\"reply?id=41534717&amp;goto=item%3Fid%3D41534179%2341534717\" rel=\"nofollow\">reply</a></u>\n                  </font>\n      </div></div></td></tr>\n        </table></td></tr>\n                  </table>\n  <br><br>\n</td></tr>\n<tr><td><img src=\"s.gif\" height=\"10\" width=\"0\"><table width=\"100%\" cellspacing=\"0\" cellpadding=\"1\"><tr><td bgcolor=\"#ff6600\"></td></tr></table><br>\n<center><span class=\"yclinks\"><a href=\"newsguidelines.html\">Guidelines</a> | <a href=\"newsfaq.html\">FAQ</a> | <a href=\"lists\">Lists</a> | <a href=\"https://github.com/HackerNews/API\">API</a> | <a href=\"security.html\">Security</a> | <a href=\"https://www.ycombinator.com/legal/\">Legal</a> | <a href=\"https://www.ycombinator.com/apply/\">Apply to YC</a> | <a href=\"mailto:hn@ycombinator.com\">Contact</a></span><br><br>\n<form method=\"get\" action=\"//hn.algolia.com/\">Search: <input type=\"text\" name=\"q\" size=\"17\" autocorrect=\"off\" spellcheck=\"false\" autocapitalize=\"off\" autocomplete=\"off\"></form></center></td></tr>      </table></center></body>\n      <script type='text/javascript' src='hn.js?rJWyZTUrrkHPi9ph1EY6'></script>\n  </html>\n",
  "text": "        Modular Monoliths Are a Good Idea | Hacker News    Hacker News  new | past | comments | ask | show | jobs | submit   login          Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                         gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply              Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:             Modular Monoliths Are a Good Idea | Hacker News Modular Monoliths Are a Good Idea | Hacker News    Hacker News  new | past | comments | ask | show | jobs | submit   login          Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                         gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply              Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:        Hacker News  new | past | comments | ask | show | jobs | submit   login          Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                         gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply              Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:      Hacker News  new | past | comments | ask | show | jobs | submit   login          Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                         gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply              Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:     Hacker News  new | past | comments | ask | show | jobs | submit   login          Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                         gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply              Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:     Hacker News  new | past | comments | ask | show | jobs | submit   login     Hacker News  new | past | comments | ask | show | jobs | submit   login     Hacker News  new | past | comments | ask | show | jobs | submit   login     Hacker News  new | past | comments | ask | show | jobs | submit   login     Hacker News  new | past | comments | ask | show | jobs | submit   login     Hacker News  new | past | comments | ask | show | jobs | submit  Hacker News  new | past | comments | ask | show | jobs | submit  Hacker News Hacker News new past comments ask show jobs submit  login   login  login      Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                         gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply              Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                         gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply              Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                   Modular Monoliths Are a Good Idea ( materializedview.io )   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments                   Modular Monoliths Are a Good Idea ( materializedview.io )     Modular Monoliths Are a Good Idea ( materializedview.io ) Modular Monoliths Are a Good Idea ( materializedview.io ) Modular Monoliths Are a Good Idea ( materializedview.io ) materializedview.io materializedview.io   35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments    35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments    35 points by riccomini  1 hour ago   | hide | past | favorite | 16 comments  35 points riccomini 1 hour ago 1 hour ago hide past favorite 16 comments                                   gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply            gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply            andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply            mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply            paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply            aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply            alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply            bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply            stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply            ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply            paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply            mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply            paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply            nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply            paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply            throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply            transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply            gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply           gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply           gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply          gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply          gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply          gwbas1c  16 minutes ago    | next  [–]      > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply    gwbas1c  16 minutes ago    | next  [–]     gwbas1c  16 minutes ago    | next  [–]    gwbas1c 16 minutes ago 16 minutes ago | next  [–]   next [–]  > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.    reply   > In practice microservices can be just as tough to wrangle as monoliths. What's worse: Premature scalability . I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction. What's worse: Premature scalability . Premature scalability I joined one project that failed because the developers spent so much time on scalability, without realizing that some basic optimization of their ORM would be enough for a single instance to scale to handle any predictable load. some basic optimization of their ORM Now I'm wrangling a product that has premature scalability. It was designed with a lot of loosely coupled services and high degrees of flexibility, but it's impossible to understand and maintain with a small team. A lot of \"cleanup\" often results in merging modules or cutting out abstraction.   reply    reply    reply  reply reply        andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply           andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply           andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply          andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply          andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply          andy_ppp  26 minutes ago    | prev | next  [–]      Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply    andy_ppp  26 minutes ago    | prev | next  [–]     andy_ppp  26 minutes ago    | prev | next  [–]    andy_ppp 26 minutes ago 26 minutes ago | prev | next  [–]   prev next [–]  Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.    reply   Elixir + Phoenix is so great at this with contexts and eventually umbrella apps. So easy to make things into apps that receive messages and services with a structure. I’m amazed it isn’t more popular really given it’s great at everything from runtime analysis to RPC/message passing to things like sockets/channels/presence and Live View.   reply    reply    reply  reply reply        mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply           mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply           mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply          mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply          mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply          mattnewton  1 hour ago    | prev | next  [–]      As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply    mattnewton  1 hour ago    | prev | next  [–]     mattnewton  1 hour ago    | prev | next  [–]    mattnewton 1 hour ago 1 hour ago | prev | next  [–]   prev next [–]  As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.    reply   As an ex-fang engineer myself, I have never advocated for more services, usually have pushed for unifying repos and multiple build targets on the same codebase. I am forever chasing the zen of google3 the way I remember it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it. If anything my sin has been forgetting how much engineering went into supporting the monorepo at Google and duo-repo at Facebook when advocating for it.   reply    reply    reply  reply reply        paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply           paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply           paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply          paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply          paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply          paperplatter  17 minutes ago    | parent | next  [–]      Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply    paperplatter  17 minutes ago    | parent | next  [–]     paperplatter  17 minutes ago    | parent | next  [–]    paperplatter 17 minutes ago 17 minutes ago | parent | next  [–]   parent next [–]  Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.    reply   Do FAANG engineers normally advocate for more services instead of fewer? I haven't gotten that impression.   reply    reply    reply  reply reply        aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply           aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply           aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply          aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply          aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply          aleksiy123  7 minutes ago    | root | parent | next  [–]      Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply    aleksiy123  7 minutes ago    | root | parent | next  [–]     aleksiy123  7 minutes ago    | root | parent | next  [–]    aleksiy123 7 minutes ago 7 minutes ago | root | parent | next  [–]   root parent next [–]  Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/    reply   Smaller services but not necessarily more binaries. The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/ The current direction I think is to build composable services that could be run together or separately. Here is some public work in this direction from Google https://serviceweaver.dev/ https://serviceweaver.dev/   reply    reply    reply  reply reply        alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply           alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply           alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply          alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply          alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply          alganet  27 minutes ago    | prev | next  [–]      A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply    alganet  27 minutes ago    | prev | next  [–]     alganet  27 minutes ago    | prev | next  [–]    alganet 27 minutes ago 27 minutes ago | prev | next  [–]   prev next [–]  A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.    reply   A good analogy is lacking though. \"Modular Monolith\" sounds like a contradiction. It doesn't help the idea. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason. It inherits culture from OOP stuff, that abstraction was leaked to repositories, then it was leaked to packages, and it's being roughly patched together into meaningless buzzwords. It's no surprise no one understands all of this. I see the react folks trying to come up with a chemical analogy (atoms, molecules and so on), and the functional guys borrowed from a pretty solid mathematical frame of mind. What is the OOP point of view missing here? Maybe it was a doomed analogy from the beginning. Let's not go into biology though, that can't do any good. Spare parts, connectors, moving parts versus passive mechanisms, subsystems. Hard separation and soft separation. It's all about that when doing component stuff. And it has been figured all out, we just keep messing how we frame it for no reason.   reply    reply    reply  reply reply        bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply           bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply           bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply          bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply          bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply          bbor  7 minutes ago    | parent | next  [–]      Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply    bbor  7 minutes ago    | parent | next  [–]     bbor  7 minutes ago    | parent | next  [–]    bbor 7 minutes ago 7 minutes ago | parent | next  [–]   parent next [–]  Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence    reply   Oo I love a terminological discussion, well said! I would disagree on your first point though: aren’t most large machines modular monoliths? Say, cars, airplanes, and dams? I absolutely agree that this usage kinda erases the original intent of the word “monolith” in a software context, though. Or at least complicates it greatly… Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all,  I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. - Alan Turing, 1950’s Computing Machinery and Intelligence Personally, I’m putting all my money on cognitive , and the terms that go along with it - say, social , agential , discursive , and conversational . Not to forget the deeper cuts from philosophy of mind (the precursor to CS!), such as dialectic (a highly-mutable data structure with holistic modification functions?), architectonic (code-generators built in to the very “top” of a system, breaking it down into a binary tree of generated-code-facilitated subsections?), and striated vs smooth systems (describes the level of obstruction/complication present in each?). cognitive social agential discursive conversational dialectic architectonic striated vs smooth Ultimately my takeaway from this article is that absolutes (namely, microservices) rarely work in real world architecture contexts. When looked at in those general terms, I think we have little choice but to start treating software like minds to be “shaped” or “sculpted”, to use Minsky’s preferred terminology. After all, I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. I believe that at the end of the century the use of words and general educated opinion will have altered so much that one will be able to speak of machines thinking without expecting to be contradicted. I believe further that no useful purpose is served by concealing these beliefs. Computing Machinery and Intelligence   reply    reply    reply  reply reply        stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply           stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply           stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply          stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply          stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply          stephen  3 minutes ago    | prev | next  [–]      I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply    stephen  3 minutes ago    | prev | next  [–]     stephen  3 minutes ago    | prev | next  [–]    stephen 3 minutes ago 3 minutes ago | prev | next  [–]   prev next [–]  I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths).    reply   I mean, of course they are a good idea, what we need is more examples of actually doing them in practice. :-) I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths). I.e. quoting from the post: - monolithic databases need to be broken up\n- Tables must be grouped by module and isolated from other modules\n- Tables must then be migrated to separate schemas\n- I am not aware of any tools that help detect such boundaries I am not aware of any tools that help detect such boundaries Exactly. For as much press as \"modular monoliths\" have gotten, breaking up a large codebase is cool/fine/whatever--breaking up a large domain model is imo the \"killer app\" of modular monoliths, and what we're missing (basically the Rails of modular monoliths). domain model   reply    reply    reply  reply reply        ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply           ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply           ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply          ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply          ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply          ljm  54 minutes ago    | prev | next  [–]      I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply    ljm  54 minutes ago    | prev | next  [–]     ljm  54 minutes ago    | prev | next  [–]    ljm 54 minutes ago 54 minutes ago | prev | next  [–]   prev next [–]  I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.    reply   I can't help but feel like the author has taken some fairly specific experiences with microservice architecture and drawn a set of conclusions that still results in microservices, but in a monorepo. There's nothing about microservices that suggests you have to go to the trouble of setting up K8s, service meshes, individual databases per service, RPC frameworks, and so on. It's all cargo culting and all this...infra... simply lines the pockets of your cloud provider of choice. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP. The end result in the context of a monolith reads more like domain driven design with a service-oriented approach and for most people working in a monolithic service, the amount of abstraction you have to layer in to make that make sense is liable to cause more trouble than it's worth. For a small, pizza-sized team it's probably going to be overkill where more time is spent managing the abstraction instead of shipping functionality that is easy to remove. If you're going to pull in something like Bazel or even an epic Makefile, and the end result is that you are publishing multiple build artifacts as part of your deploy, it's not really a monolith any more, it's just a monorepo. Nothing wrong with that either; certainly a lot easier to work with compared to bouncing around multiple separate repos. Fundamentally I think that you're just choosing if you want a wide codebase or a deep one. If somehow you end up with both at the same time then you end up with experiences similar to OP.   reply    reply    reply  reply reply        paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply           paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply           paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply          paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply          paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply          paperplatter  21 minutes ago    | parent | next  [–]      I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply    paperplatter  21 minutes ago    | parent | next  [–]     paperplatter  21 minutes ago    | parent | next  [–]    paperplatter 21 minutes ago 21 minutes ago | parent | next  [–]   parent next [–]  I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.    reply   I think the assumption here is that \"microservices\" means each team is dealing with lots of services. Sometimes it's like that. But if you go by the \"one service <=> one database\" rule of thumb, there will probably be 1-3 services per team. And when you want to use other teams' stuff, you'll be thankful it's across an RPC. Especially if you don't agree with that other team on what language to write in. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent. It'd really help to see a concrete example of a modular monolith compared to the microservice equivalent.   reply    reply    reply  reply reply        mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply           mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply           mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply          mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply          mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply          mushufasa  38 minutes ago    | prev | next  [–]      Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply    mushufasa  38 minutes ago    | prev | next  [–]     mushufasa  38 minutes ago    | prev | next  [–]    mushufasa 38 minutes ago 38 minutes ago | prev | next  [–]   prev next [–]  Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.    reply   Would Django's concept of an 'app' fit your definition of modular monoliths? https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'. https://docs.djangoproject.com/en/5.1/ref/applications/ https://docs.djangoproject.com/en/5.1/ref/applications/ In a nutshell, each django project is an 'app' and you can 'install' multiple apps together. They can come with their own database tables + migrations. But all live under the same gunicorn and on the same infra, within the same codebase. Many Django plugins are setup as an 'app'.   reply    reply    reply  reply reply        paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply           paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply           paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply          paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply          paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply          paperplatter  1 hour ago    | prev | next  [–]      \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply    paperplatter  1 hour ago    | prev | next  [–]     paperplatter  1 hour ago    | prev | next  [–]    paperplatter 1 hour ago 1 hour ago | prev | next  [–]   prev next [–]  \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs?    reply   \"To get similar characteristics from a monolith, developers need:  Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" This sounds a lot like microservices, most of all the last point. Is the only difference that you don't use RPCs? Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\" Incremental build systems\n\n    Incremental testing frameworks\n\n    Branch management tooling\n\n    Code isolation enforcement\n\n    Database isolation enforcement\"   reply    reply    reply  reply reply        nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply           nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply           nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply          nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply          nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply          nine_k  51 minutes ago    | parent | next  [–]      > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply    nine_k  51 minutes ago    | parent | next  [–]     nine_k  51 minutes ago    | parent | next  [–]    nine_k 51 minutes ago 51 minutes ago | parent | next  [–]   parent next [–]  > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.    reply   > the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module. the only difference that you don't use RPCs But it's a huge difference. No RPC overhead. No lost / duplicate PRC messages. All logs can literally go to the same file (via e.g. simple syslog). huge Local deployment is dead simple, and you can't forget to start any service. Prod deployment never needs to handle a mix of versions among deployed services. Beside that, the build step is much simpler. Common libraries' versions can never diverge, because there's one copy per the whole binary (can be a disadvantage sometimes, too). You can attach a debugger and follow the entire chain, even if it crosses the boundaries of the modules. With that, you can make self-contained modules as small is it makes logical sense. You can pretty cheaply move pieces of functionality from one module to another, if it makes better sense. It's trivially easy to factor out common parts into another self-contained module. Still you have all the advantages of fast incremental / partial builds, contained dependencies, and some of the advantages of isolated / parallel testing. But most importantly, it preserves your sanity by limiting the scope of most changes to a single module.   reply    reply    reply  reply reply        paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply           paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply           paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply          paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply          paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply          paperplatter  28 minutes ago    | root | parent | next  [–]      There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply    paperplatter  28 minutes ago    | root | parent | next  [–]     paperplatter  28 minutes ago    | root | parent | next  [–]    paperplatter 28 minutes ago 28 minutes ago | root | parent | next  [–]   root parent next [–]  There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.    reply   There would be a mix of versions, managed via branches. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally. The part about debuggability sounded appealing at first, but if the multiple services you want to run are truly that hard to spin up locally, it won't be any easier as a monorepo. First thing you'll do is pass in 30 flags for the different databases to use. If these were RPCs, you could use some common prod or staging instance for things you don't want to bother running locally.   reply    reply    reply  reply reply        throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply           throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply           throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply          throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply          throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply          throwaway984393  1 hour ago    | prev  [–]      I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply    throwaway984393  1 hour ago    | prev  [–]     throwaway984393  1 hour ago    | prev  [–]    throwaway984393 1 hour ago 1 hour ago | prev  [–]   prev [–]  I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.    reply   I'm nearing greybeard status, so I have to chime in on the \"get off my lawn\" aspect. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation. There is no one general \"good engineering\". Everything is different. Labels suck because even if you called one thing \"microservices\", or even \"monolith of microservices\", I can show you 10 different ways that can end up. So \"modular monolith\" is just as useless a descriptor; it's too vague. Outside of the HN echo chamber, good engineering practice has been happening for decades. Take open source for example. Many different projects exist with many different designs. The common thread is that if a project creates some valuable functionality, they tend to expose it both at the application layer and library layer. They know some external app will want to integrate with it, but also they know somebody might want to extend the core functionality. I personally haven't seen that method used at corporations. If there are libraries, they're almost always completely independent from an application. And because of that, they then become shared across many applications. And then they suddenly discover the thing open source has been dealing with for decades: dependency. If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. So yes, there are modular moniliths, and unmodular monoliths, and microservices, and libraries, and a whole lot of varied designs and use cases. Don't just learn about these by reading trendy blog posts on HN. Go find some open source code and examine it. Package some annoying ass complex software. Patch a bug and release an update. These are practical lessons you can take with you when you design for a corporation.   reply    reply    reply  reply reply        transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply           transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply           transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply          transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply          transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply          transpute  50 minutes ago    | parent  [–]      > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply    transpute  50 minutes ago    | parent  [–]     transpute  50 minutes ago    | parent  [–]    transpute 50 minutes ago 50 minutes ago | parent  [–]   parent [–]  > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.    reply   > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships. > If you aren't aware, there is an entire universe out there of people working solely on managing dependencies so that you, a developer or user, can \"just\" install software into your computer and have it magically work. It is fucking hard and complicated and necessary. If you've never done packaging for a distro or a language (and I mean 250+ hours of it), you won't understand how much work it is or how it will affect your own projects. When new employees joined the engineering org at a former employer, they were required to spend six months on the sustaining team, where they could be assigned customer-escalated bugs in any part of the codebase.  Under the clock to deliver a hotfix for production customers, they would be required to learn a new area of the complex codebase, work with specialists in that area, develop/test a fix and shepherd it through review/approval by senior engineers. There is much for developers to learn from a period of apprenticeship in cross-platform software packaging. Start with .deb/.rpm, then image customization, A/B upgrades, stateless systems and work up to reproducible builds with Yocto, NixOS, Guix. In the next few years, SBOMs (software \"bill of materials\" aka package provenance) will become mandatory in some regional and vertical markets. This will either cause a reduction in dependencies, or increased attention to software supply chain relationships.   reply    reply    reply  reply reply     Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:      Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:     Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact    Search:  Guidelines | FAQ | Lists | API | Security | Legal | Apply to YC | Contact Guidelines FAQ Lists API Security Legal Apply to YC Contact Search: ",
  "links": [
    {
      "id": 1,
      "url": "https://news.ycombinator.com/",
      "html": "<a href=\"https://news.ycombinator.com\"><img src=\"y18.svg\" width=\"18\" height=\"18\" style=\"border:1px white solid; display:block\"></a>",
      "text": ""
    },
    {
      "id": 2,
      "url": "https://news.ycombinator.com/news",
      "html": "<a href=\"news\">Hacker News</a>",
      "text": "Hacker News"
    },
    {
      "id": 3,
      "url": "https://news.ycombinator.com/newest",
      "html": "<a href=\"newest\">new</a>",
      "text": "new"
    },
    {
      "id": 4,
      "url": "https://news.ycombinator.com/front",
      "html": "<a href=\"front\">past</a>",
      "text": "past"
    },
    {
      "id": 5,
      "url": "https://news.ycombinator.com/newcomments",
      "html": "<a href=\"newcomments\">comments</a>",
      "text": "comments"
    },
    {
      "id": 6,
      "url": "https://news.ycombinator.com/ask",
      "html": "<a href=\"ask\">ask</a>",
      "text": "ask"
    },
    {
      "id": 7,
      "url": "https://news.ycombinator.com/show",
      "html": "<a href=\"show\">show</a>",
      "text": "show"
    },
    {
      "id": 8,
      "url": "https://news.ycombinator.com/jobs",
      "html": "<a href=\"jobs\">jobs</a>",
      "text": "jobs"
    },
    {
      "id": 9,
      "url": "https://news.ycombinator.com/submit",
      "html": "<a href=\"submit\" rel=\"nofollow\">submit</a>",
      "text": "submit"
    },
    {
      "id": 10,
      "url": "https://news.ycombinator.com/login?goto=item%3Fid%3D41534179",
      "html": "<a href=\"login?goto=item%3Fid%3D41534179\">login</a>",
      "text": "login"
    },
    {
      "id": 11,
      "url": "https://news.ycombinator.com/vote?id=41534179&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534179\" href=\"vote?id=41534179&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 12,
      "url": "https://materializedview.io/p/modular-monoliths-are-a-good-idea",
      "html": "<a href=\"https://materializedview.io/p/modular-monoliths-are-a-good-idea\">Modular Monoliths Are a Good Idea</a>",
      "text": "Modular Monoliths Are a Good Idea"
    },
    {
      "id": 13,
      "url": "https://news.ycombinator.com/from?site=materializedview.io",
      "html": "<a href=\"from?site=materializedview.io\"><span class=\"sitestr\">materializedview.io</span></a>",
      "text": "materializedview.io"
    },
    {
      "id": 14,
      "url": "https://news.ycombinator.com/user?id=riccomini",
      "html": "<a href=\"user?id=riccomini\" class=\"hnuser\">riccomini</a>",
      "text": "riccomini"
    },
    {
      "id": 15,
      "url": "https://news.ycombinator.com/item?id=41534179",
      "html": "<a href=\"item?id=41534179\">1 hour ago</a>",
      "text": "1 hour ago"
    },
    {
      "id": 16,
      "url": "https://news.ycombinator.com/hide?id=41534179&goto=item%3Fid%3D41534179",
      "html": "<a href=\"hide?id=41534179&amp;goto=item%3Fid%3D41534179\">hide</a>",
      "text": "hide"
    },
    {
      "id": 17,
      "url": "https://hn.algolia.com/?query=Modular%20Monoliths%20Are%20a%20Good%20Idea&type=story&dateRange=all&sort=byDate&storyText=false&prefix&page=0",
      "html": "<a href=\"https://hn.algolia.com/?query=Modular%20Monoliths%20Are%20a%20Good%20Idea&amp;type=story&amp;dateRange=all&amp;sort=byDate&amp;storyText=false&amp;prefix&amp;page=0\" class=\"hnpast\">past</a>",
      "text": "past"
    },
    {
      "id": 18,
      "url": "https://news.ycombinator.com/fave?id=41534179&auth=798ee675e92211599bedae60e47583e703d859e8",
      "html": "<a href=\"fave?id=41534179&amp;auth=798ee675e92211599bedae60e47583e703d859e8\">favorite</a>",
      "text": "favorite"
    },
    {
      "id": 19,
      "url": "https://news.ycombinator.com/item?id=41534179",
      "html": "<a href=\"item?id=41534179\">16&nbsp;comments</a>",
      "text": "16 comments"
    },
    {
      "id": 20,
      "url": "https://news.ycombinator.com/vote?id=41534995&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534995\" href=\"vote?id=41534995&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 21,
      "url": "https://news.ycombinator.com/user?id=gwbas1c",
      "html": "<a href=\"user?id=gwbas1c\" class=\"hnuser\">gwbas1c</a>",
      "text": "gwbas1c"
    },
    {
      "id": 22,
      "url": "https://news.ycombinator.com/item?id=41534995",
      "html": "<a href=\"item?id=41534995\">16 minutes ago</a>",
      "text": "16 minutes ago"
    },
    {
      "id": 23,
      "url": "https://news.ycombinator.com/item?id=41534179#41534922",
      "html": "<a href=\"#41534922\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 24,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534995\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 25,
      "url": "https://news.ycombinator.com/reply?id=41534995&goto=item%3Fid%3D41534179%2341534995",
      "html": "<a href=\"reply?id=41534995&amp;goto=item%3Fid%3D41534179%2341534995\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 26,
      "url": "https://news.ycombinator.com/vote?id=41534922&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534922\" href=\"vote?id=41534922&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 27,
      "url": "https://news.ycombinator.com/user?id=andy_ppp",
      "html": "<a href=\"user?id=andy_ppp\" class=\"hnuser\">andy_ppp</a>",
      "text": "andy_ppp"
    },
    {
      "id": 28,
      "url": "https://news.ycombinator.com/item?id=41534922",
      "html": "<a href=\"item?id=41534922\">26 minutes ago</a>",
      "text": "26 minutes ago"
    },
    {
      "id": 29,
      "url": "https://news.ycombinator.com/item?id=41534179#41534995",
      "html": "<a href=\"#41534995\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 30,
      "url": "https://news.ycombinator.com/item?id=41534179#41534491",
      "html": "<a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 31,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534922\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 32,
      "url": "https://news.ycombinator.com/reply?id=41534922&goto=item%3Fid%3D41534179%2341534922",
      "html": "<a href=\"reply?id=41534922&amp;goto=item%3Fid%3D41534179%2341534922\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 33,
      "url": "https://news.ycombinator.com/vote?id=41534491&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534491\" href=\"vote?id=41534491&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 34,
      "url": "https://news.ycombinator.com/user?id=mattnewton",
      "html": "<a href=\"user?id=mattnewton\" class=\"hnuser\">mattnewton</a>",
      "text": "mattnewton"
    },
    {
      "id": 35,
      "url": "https://news.ycombinator.com/item?id=41534491",
      "html": "<a href=\"item?id=41534491\">1 hour ago</a>",
      "text": "1 hour ago"
    },
    {
      "id": 36,
      "url": "https://news.ycombinator.com/item?id=41534179#41534922",
      "html": "<a href=\"#41534922\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 37,
      "url": "https://news.ycombinator.com/item?id=41534179#41534906",
      "html": "<a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 38,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534491\" n=\"3\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 39,
      "url": "https://news.ycombinator.com/reply?id=41534491&goto=item%3Fid%3D41534179%2341534491",
      "html": "<a href=\"reply?id=41534491&amp;goto=item%3Fid%3D41534179%2341534491\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 40,
      "url": "https://news.ycombinator.com/vote?id=41534984&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534984\" href=\"vote?id=41534984&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 41,
      "url": "https://news.ycombinator.com/user?id=paperplatter",
      "html": "<a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a>",
      "text": "paperplatter"
    },
    {
      "id": 42,
      "url": "https://news.ycombinator.com/item?id=41534984",
      "html": "<a href=\"item?id=41534984\">17 minutes ago</a>",
      "text": "17 minutes ago"
    },
    {
      "id": 43,
      "url": "https://news.ycombinator.com/item?id=41534179#41534491",
      "html": "<a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">parent</a>",
      "text": "parent"
    },
    {
      "id": 44,
      "url": "https://news.ycombinator.com/item?id=41534179#41534906",
      "html": "<a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 45,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534984\" n=\"2\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 46,
      "url": "https://news.ycombinator.com/reply?id=41534984&goto=item%3Fid%3D41534179%2341534984",
      "html": "<a href=\"reply?id=41534984&amp;goto=item%3Fid%3D41534179%2341534984\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 47,
      "url": "https://news.ycombinator.com/vote?id=41535070&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41535070\" href=\"vote?id=41535070&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 48,
      "url": "https://news.ycombinator.com/user?id=aleksiy123",
      "html": "<a href=\"user?id=aleksiy123\" class=\"hnuser\">aleksiy123</a>",
      "text": "aleksiy123"
    },
    {
      "id": 49,
      "url": "https://news.ycombinator.com/item?id=41535070",
      "html": "<a href=\"item?id=41535070\">7 minutes ago</a>",
      "text": "7 minutes ago"
    },
    {
      "id": 50,
      "url": "https://news.ycombinator.com/item?id=41534179#41534491",
      "html": "<a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">root</a>",
      "text": "root"
    },
    {
      "id": 51,
      "url": "https://news.ycombinator.com/item?id=41534179#41534984",
      "html": "<a href=\"#41534984\" class=\"clicky\" aria-hidden=\"true\">parent</a>",
      "text": "parent"
    },
    {
      "id": 52,
      "url": "https://news.ycombinator.com/item?id=41534179#41534906",
      "html": "<a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 53,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41535070\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 54,
      "url": "https://serviceweaver.dev/",
      "html": "<a href=\"https://serviceweaver.dev/\" rel=\"nofollow\">https://serviceweaver.dev/</a>",
      "text": "https://serviceweaver.dev/"
    },
    {
      "id": 55,
      "url": "https://news.ycombinator.com/reply?id=41535070&goto=item%3Fid%3D41534179%2341535070",
      "html": "<a href=\"reply?id=41535070&amp;goto=item%3Fid%3D41534179%2341535070\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 56,
      "url": "https://news.ycombinator.com/vote?id=41534906&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534906\" href=\"vote?id=41534906&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 57,
      "url": "https://news.ycombinator.com/user?id=alganet",
      "html": "<a href=\"user?id=alganet\" class=\"hnuser\">alganet</a>",
      "text": "alganet"
    },
    {
      "id": 58,
      "url": "https://news.ycombinator.com/item?id=41534906",
      "html": "<a href=\"item?id=41534906\">27 minutes ago</a>",
      "text": "27 minutes ago"
    },
    {
      "id": 59,
      "url": "https://news.ycombinator.com/item?id=41534179#41534491",
      "html": "<a href=\"#41534491\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 60,
      "url": "https://news.ycombinator.com/item?id=41534179#41535107",
      "html": "<a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 61,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534906\" n=\"2\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 62,
      "url": "https://news.ycombinator.com/reply?id=41534906&goto=item%3Fid%3D41534179%2341534906",
      "html": "<a href=\"reply?id=41534906&amp;goto=item%3Fid%3D41534179%2341534906\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 63,
      "url": "https://news.ycombinator.com/vote?id=41535073&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41535073\" href=\"vote?id=41535073&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 64,
      "url": "https://news.ycombinator.com/user?id=bbor",
      "html": "<a href=\"user?id=bbor\" class=\"hnuser\">bbor</a>",
      "text": "bbor"
    },
    {
      "id": 65,
      "url": "https://news.ycombinator.com/item?id=41535073",
      "html": "<a href=\"item?id=41535073\">7 minutes ago</a>",
      "text": "7 minutes ago"
    },
    {
      "id": 66,
      "url": "https://news.ycombinator.com/item?id=41534179#41534906",
      "html": "<a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">parent</a>",
      "text": "parent"
    },
    {
      "id": 67,
      "url": "https://news.ycombinator.com/item?id=41534179#41535107",
      "html": "<a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 68,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41535073\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 69,
      "url": "https://news.ycombinator.com/reply?id=41535073&goto=item%3Fid%3D41534179%2341535073",
      "html": "<a href=\"reply?id=41535073&amp;goto=item%3Fid%3D41534179%2341535073\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 70,
      "url": "https://news.ycombinator.com/vote?id=41535107&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41535107\" href=\"vote?id=41535107&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 71,
      "url": "https://news.ycombinator.com/user?id=stephen",
      "html": "<a href=\"user?id=stephen\" class=\"hnuser\">stephen</a>",
      "text": "stephen"
    },
    {
      "id": 72,
      "url": "https://news.ycombinator.com/item?id=41535107",
      "html": "<a href=\"item?id=41535107\">3 minutes ago</a>",
      "text": "3 minutes ago"
    },
    {
      "id": 73,
      "url": "https://news.ycombinator.com/item?id=41534179#41534906",
      "html": "<a href=\"#41534906\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 74,
      "url": "https://news.ycombinator.com/item?id=41534179#41534678",
      "html": "<a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 75,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41535107\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 76,
      "url": "https://news.ycombinator.com/reply?id=41535107&goto=item%3Fid%3D41534179%2341535107",
      "html": "<a href=\"reply?id=41535107&amp;goto=item%3Fid%3D41534179%2341535107\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 77,
      "url": "https://news.ycombinator.com/vote?id=41534678&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534678\" href=\"vote?id=41534678&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 78,
      "url": "https://news.ycombinator.com/user?id=ljm",
      "html": "<a href=\"user?id=ljm\" class=\"hnuser\">ljm</a>",
      "text": "ljm"
    },
    {
      "id": 79,
      "url": "https://news.ycombinator.com/item?id=41534678",
      "html": "<a href=\"item?id=41534678\">54 minutes ago</a>",
      "text": "54 minutes ago"
    },
    {
      "id": 80,
      "url": "https://news.ycombinator.com/item?id=41534179#41535107",
      "html": "<a href=\"#41535107\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 81,
      "url": "https://news.ycombinator.com/item?id=41534179#41534813",
      "html": "<a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 82,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534678\" n=\"2\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 83,
      "url": "https://news.ycombinator.com/reply?id=41534678&goto=item%3Fid%3D41534179%2341534678",
      "html": "<a href=\"reply?id=41534678&amp;goto=item%3Fid%3D41534179%2341534678\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 84,
      "url": "https://news.ycombinator.com/vote?id=41534954&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534954\" href=\"vote?id=41534954&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 85,
      "url": "https://news.ycombinator.com/user?id=paperplatter",
      "html": "<a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a>",
      "text": "paperplatter"
    },
    {
      "id": 86,
      "url": "https://news.ycombinator.com/item?id=41534954",
      "html": "<a href=\"item?id=41534954\">21 minutes ago</a>",
      "text": "21 minutes ago"
    },
    {
      "id": 87,
      "url": "https://news.ycombinator.com/item?id=41534179#41534678",
      "html": "<a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">parent</a>",
      "text": "parent"
    },
    {
      "id": 88,
      "url": "https://news.ycombinator.com/item?id=41534179#41534813",
      "html": "<a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 89,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534954\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 90,
      "url": "https://news.ycombinator.com/reply?id=41534954&goto=item%3Fid%3D41534179%2341534954",
      "html": "<a href=\"reply?id=41534954&amp;goto=item%3Fid%3D41534179%2341534954\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 91,
      "url": "https://news.ycombinator.com/vote?id=41534813&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534813\" href=\"vote?id=41534813&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 92,
      "url": "https://news.ycombinator.com/user?id=mushufasa",
      "html": "<a href=\"user?id=mushufasa\" class=\"hnuser\">mushufasa</a>",
      "text": "mushufasa"
    },
    {
      "id": 93,
      "url": "https://news.ycombinator.com/item?id=41534813",
      "html": "<a href=\"item?id=41534813\">38 minutes ago</a>",
      "text": "38 minutes ago"
    },
    {
      "id": 94,
      "url": "https://news.ycombinator.com/item?id=41534179#41534678",
      "html": "<a href=\"#41534678\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 95,
      "url": "https://news.ycombinator.com/item?id=41534179#41534507",
      "html": "<a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 96,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534813\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 97,
      "url": "https://docs.djangoproject.com/en/5.1/ref/applications/",
      "html": "<a href=\"https://docs.djangoproject.com/en/5.1/ref/applications/\" rel=\"nofollow\">https://docs.djangoproject.com/en/5.1/ref/applications/</a>",
      "text": "https://docs.djangoproject.com/en/5.1/ref/applications/"
    },
    {
      "id": 98,
      "url": "https://news.ycombinator.com/reply?id=41534813&goto=item%3Fid%3D41534179%2341534813",
      "html": "<a href=\"reply?id=41534813&amp;goto=item%3Fid%3D41534179%2341534813\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 99,
      "url": "https://news.ycombinator.com/vote?id=41534507&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534507\" href=\"vote?id=41534507&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 100,
      "url": "https://news.ycombinator.com/user?id=paperplatter",
      "html": "<a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a>",
      "text": "paperplatter"
    },
    {
      "id": 101,
      "url": "https://news.ycombinator.com/item?id=41534507",
      "html": "<a href=\"item?id=41534507\">1 hour ago</a>",
      "text": "1 hour ago"
    },
    {
      "id": 102,
      "url": "https://news.ycombinator.com/item?id=41534179#41534813",
      "html": "<a href=\"#41534813\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 103,
      "url": "https://news.ycombinator.com/item?id=41534179#41534529",
      "html": "<a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 104,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534507\" n=\"3\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 105,
      "url": "https://news.ycombinator.com/reply?id=41534507&goto=item%3Fid%3D41534179%2341534507",
      "html": "<a href=\"reply?id=41534507&amp;goto=item%3Fid%3D41534179%2341534507\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 106,
      "url": "https://news.ycombinator.com/vote?id=41534703&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534703\" href=\"vote?id=41534703&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 107,
      "url": "https://news.ycombinator.com/user?id=nine_k",
      "html": "<a href=\"user?id=nine_k\" class=\"hnuser\">nine_k</a>",
      "text": "nine_k"
    },
    {
      "id": 108,
      "url": "https://news.ycombinator.com/item?id=41534703",
      "html": "<a href=\"item?id=41534703\">51 minutes ago</a>",
      "text": "51 minutes ago"
    },
    {
      "id": 109,
      "url": "https://news.ycombinator.com/item?id=41534179#41534507",
      "html": "<a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">parent</a>",
      "text": "parent"
    },
    {
      "id": 110,
      "url": "https://news.ycombinator.com/item?id=41534179#41534529",
      "html": "<a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 111,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534703\" n=\"2\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 112,
      "url": "https://news.ycombinator.com/reply?id=41534703&goto=item%3Fid%3D41534179%2341534703",
      "html": "<a href=\"reply?id=41534703&amp;goto=item%3Fid%3D41534179%2341534703\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 113,
      "url": "https://news.ycombinator.com/vote?id=41534898&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534898\" href=\"vote?id=41534898&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 114,
      "url": "https://news.ycombinator.com/user?id=paperplatter",
      "html": "<a href=\"user?id=paperplatter\" class=\"hnuser\">paperplatter</a>",
      "text": "paperplatter"
    },
    {
      "id": 115,
      "url": "https://news.ycombinator.com/item?id=41534898",
      "html": "<a href=\"item?id=41534898\">28 minutes ago</a>",
      "text": "28 minutes ago"
    },
    {
      "id": 116,
      "url": "https://news.ycombinator.com/item?id=41534179#41534507",
      "html": "<a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">root</a>",
      "text": "root"
    },
    {
      "id": 117,
      "url": "https://news.ycombinator.com/item?id=41534179#41534703",
      "html": "<a href=\"#41534703\" class=\"clicky\" aria-hidden=\"true\">parent</a>",
      "text": "parent"
    },
    {
      "id": 118,
      "url": "https://news.ycombinator.com/item?id=41534179#41534529",
      "html": "<a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">next</a>",
      "text": "next"
    },
    {
      "id": 119,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534898\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 120,
      "url": "https://news.ycombinator.com/reply?id=41534898&goto=item%3Fid%3D41534179%2341534898",
      "html": "<a href=\"reply?id=41534898&amp;goto=item%3Fid%3D41534179%2341534898\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 121,
      "url": "https://news.ycombinator.com/vote?id=41534529&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534529\" href=\"vote?id=41534529&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 122,
      "url": "https://news.ycombinator.com/user?id=throwaway984393",
      "html": "<a href=\"user?id=throwaway984393\" class=\"hnuser\">throwaway984393</a>",
      "text": "throwaway984393"
    },
    {
      "id": 123,
      "url": "https://news.ycombinator.com/item?id=41534529",
      "html": "<a href=\"item?id=41534529\">1 hour ago</a>",
      "text": "1 hour ago"
    },
    {
      "id": 124,
      "url": "https://news.ycombinator.com/item?id=41534179#41534507",
      "html": "<a href=\"#41534507\" class=\"clicky\" aria-hidden=\"true\">prev</a>",
      "text": "prev"
    },
    {
      "id": 125,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534529\" n=\"2\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 126,
      "url": "https://news.ycombinator.com/reply?id=41534529&goto=item%3Fid%3D41534179%2341534529",
      "html": "<a href=\"reply?id=41534529&amp;goto=item%3Fid%3D41534179%2341534529\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 127,
      "url": "https://news.ycombinator.com/vote?id=41534717&how=up&goto=item%3Fid%3D41534179",
      "html": "<a id=\"up_41534717\" href=\"vote?id=41534717&amp;how=up&amp;goto=item%3Fid%3D41534179\"><div class=\"votearrow\" title=\"upvote\"></div></a>",
      "text": ""
    },
    {
      "id": 128,
      "url": "https://news.ycombinator.com/user?id=transpute",
      "html": "<a href=\"user?id=transpute\" class=\"hnuser\">transpute</a>",
      "text": "transpute"
    },
    {
      "id": 129,
      "url": "https://news.ycombinator.com/item?id=41534717",
      "html": "<a href=\"item?id=41534717\">50 minutes ago</a>",
      "text": "50 minutes ago"
    },
    {
      "id": 130,
      "url": "https://news.ycombinator.com/item?id=41534179#41534529",
      "html": "<a href=\"#41534529\" class=\"clicky\" aria-hidden=\"true\">parent</a>",
      "text": "parent"
    },
    {
      "id": 131,
      "url": "javascript:void(0)",
      "html": "<a class=\"togg clicky\" id=\"41534717\" n=\"1\" href=\"javascript:void(0)\">[–]</a>",
      "text": "[–]"
    },
    {
      "id": 132,
      "url": "https://news.ycombinator.com/reply?id=41534717&goto=item%3Fid%3D41534179%2341534717",
      "html": "<a href=\"reply?id=41534717&amp;goto=item%3Fid%3D41534179%2341534717\" rel=\"nofollow\">reply</a>",
      "text": "reply"
    },
    {
      "id": 133,
      "url": "https://news.ycombinator.com/newsguidelines.html",
      "html": "<a href=\"newsguidelines.html\">Guidelines</a>",
      "text": "Guidelines"
    },
    {
      "id": 134,
      "url": "https://news.ycombinator.com/newsfaq.html",
      "html": "<a href=\"newsfaq.html\">FAQ</a>",
      "text": "FAQ"
    },
    {
      "id": 135,
      "url": "https://news.ycombinator.com/lists",
      "html": "<a href=\"lists\">Lists</a>",
      "text": "Lists"
    },
    {
      "id": 136,
      "url": "https://github.com/HackerNews/API",
      "html": "<a href=\"https://github.com/HackerNews/API\">API</a>",
      "text": "API"
    },
    {
      "id": 137,
      "url": "https://news.ycombinator.com/security.html",
      "html": "<a href=\"security.html\">Security</a>",
      "text": "Security"
    },
    {
      "id": 138,
      "url": "https://www.ycombinator.com/legal/",
      "html": "<a href=\"https://www.ycombinator.com/legal/\">Legal</a>",
      "text": "Legal"
    },
    {
      "id": 139,
      "url": "https://www.ycombinator.com/apply/",
      "html": "<a href=\"https://www.ycombinator.com/apply/\">Apply to YC</a>",
      "text": "Apply to YC"
    },
    {
      "id": 140,
      "url": "mailto:hn@ycombinator.com",
      "html": "<a href=\"mailto:hn@ycombinator.com\">Contact</a>",
      "text": "Contact"
    }
  ],
  "resp": {
    "url": "https://news.ycombinator.com/item?id=41534179",
    "status": 200,
    "statusText": "OK",
    "headers": {
      "cache-control": "private; max-age=0",
      "connection": "close",
      "content-encoding": "gzip",
      "content-security-policy": "default-src 'self'; script-src 'self' 'unsafe-inline' https://www.google.com/recaptcha/ https://www.gstatic.com/recaptcha/ https://cdnjs.cloudflare.com/; frame-src 'self' https://www.google.com/recaptcha/; style-src 'self' 'unsafe-inline'; img-src 'self' https://account.ycombinator.com; frame-ancestors 'self'",
      "content-type": "text/html; charset=utf-8",
      "date": "Fri, 13 Sep 2024 21:07:20 GMT",
      "referrer-policy": "origin",
      "server": "nginx",
      "strict-transport-security": "max-age=31556900",
      "transfer-encoding": "chunked",
      "vary": "Accept-Encoding",
      "x-content-type-options": "nosniff",
      "x-frame-options": "DENY",
      "x-xss-protection": "1; mode=block"
    }
  },
  "contentType": "text/html",
  "req": {
    "url": "https://news.ycombinator.com/item?id=41534179"
  }
}